name: CI/CD Pipeline - Golang with AWS Secrets

on:
  push:
    branches: [main, dev]
  pull_request:
    branches: [main, dev]

env:
  AWS_REGION: ap-southeast-3
  ECR_REPOSITORY: suitemedia-app
  EKS_CLUSTER_NAME: production-eks-cluster
  GO_VERSION: '1.21'

jobs:
  # ============================================
  # Stage 1: Code Static Analysis
  # ============================================
  code-analysis:
    name: Code Static Analysis
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: ${{ env.GO_VERSION }}

      - name: Cache Go Modules
        uses: actions/cache@v4
        with:
          path: |
            ~/.cache/go-build
            ~/go/pkg/mod
          key: ${{ runner.os }}-go-${{ hashFiles('**/go.sum') }}

      - name: Download Dependencies
        run: go mod download

      - name: Verify Dependencies
        run: go mod verify

      - name: Run Go Vet
        run: go vet ./...

      - name: Run Go Fmt Check
        run: |
          if [ "$(gofmt -s -l . | wc -l)" -gt 0 ]; then
            echo "❌ Code is not formatted. Please run 'go fmt ./...'"
            gofmt -s -l .
            exit 1
          fi
          echo "✅ Code formatting is correct"

      - name: Install staticcheck
        run: go install honnef.co/go/tools/cmd/staticcheck@latest

      - name: Run staticcheck
        run: staticcheck ./...

      - name: Install gosec (Security Scanner)
        run: go install github.com/securego/gosec/v2/cmd/gosec@latest

      - name: Run gosec Security Scan
        run: gosec -fmt=json -out=gosec-report.json ./...
        continue-on-error: true

      - name: Upload Security Report
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: security-report
          path: gosec-report.json
          retention-days: 30

      - name: Install golangci-lint
        run: |
          curl -sSfL https://raw.githubusercontent.com/golangci/golangci-lint/master/install.sh | sh -s -- -b $(go env GOPATH)/bin v1.55.2

      - name: Run golangci-lint
        run: golangci-lint run --timeout=5m --out-format=colored-line-number
        continue-on-error: true

  # ============================================
  # Stage 2: Unit Test
  # ============================================
  unit-test:
    name: Unit Tests
    runs-on: ubuntu-latest
    needs: code-analysis
    
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: ${{ env.GO_VERSION }}

      - name: Cache Go Modules
        uses: actions/cache@v4
        with:
          path: |
            ~/.cache/go-build
            ~/go/pkg/mod
          key: ${{ runner.os }}-go-${{ hashFiles('**/go.sum') }}

      - name: Download Dependencies
        run: go mod download

      - name: Run Unit Tests
        run: go test -v -race -coverprofile=coverage.out -covermode=atomic ./...

      - name: Generate Coverage Report
        run: go tool cover -html=coverage.out -o coverage.html

      - name: Check Coverage Threshold
        run: |
          COVERAGE=$(go tool cover -func=coverage.out | grep total | awk '{print $3}' | sed 's/%//')
          echo "Total Coverage: ${COVERAGE}%"
          
          # Check coverage excluding main and generated files
          COVERED_COVERAGE=$(go tool cover -func=coverage.out | grep -v "cmd/api/main.go" | grep -v "/mocks/" | grep total | awk '{print $3}' | sed 's/%//' || echo "0")
          echo "Coverage (excluding main): ${COVERED_COVERAGE}%"
          
          # For initial setup, we'll allow lower coverage but log it
          if (( $(echo "$COVERAGE < 10" | bc -l) )); then
            echo "⚠️  Coverage is below 10% - Consider adding more tests"
          else
            echo "✅ Coverage check passed: ${COVERAGE}%"
          fi

      - name: Upload Coverage to Codecov
        uses: codecov/codecov-action@v4
        with:
          files: ./coverage.out
          flags: unittests
          name: codecov-umbrella

      - name: Upload Coverage Report
        uses: actions/upload-artifact@v4
        with:
          name: coverage-report
          path: |
            coverage.out
            coverage.html
          retention-days: 30

  # ============================================
  # Stage 3: Integration Test
  # ============================================
  integration-test:
    name: Integration Tests
    runs-on: ubuntu-latest
    needs: unit-test
    
    services:
      postgres:
        image: postgres:15-alpine
        env:
          POSTGRES_USER: test_user
          POSTGRES_PASSWORD: test_password
          POSTGRES_DB: test_db
        ports:
          - 5432:5432
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5

      redis:
        image: redis:7-alpine
        ports:
          - 6379:6379
        options: >-
          --health-cmd "timeout 5 redis-cli ping || exit 1"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5

    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: ${{ env.GO_VERSION }}

      - name: Cache Go Modules
        uses: actions/cache@v4
        with:
          path: |
            ~/.cache/go-build
            ~/go/pkg/mod
          key: ${{ runner.os }}-go-${{ hashFiles('**/go.sum') }}

      - name: Download Dependencies
        run: go mod download

      - name: Install Redis Tools
        run: sudo apt-get update && sudo apt-get install -y redis-tools

      - name: Wait for Services
        run: |
          echo "Waiting for PostgreSQL..."
          for i in {1..30}; do
            if pg_isready -h localhost -p 5432 -U test_user; then
              echo "✅ PostgreSQL is ready"
              break
            fi
            sleep 1
          done
          
          echo "Waiting for Redis..."
          for i in {1..30}; do
            if redis-cli -h localhost ping; then
              echo "✅ Redis is ready"
              break
            fi
            sleep 1
          done

      - name: Run Integration Tests
        run: go test -v -tags=integration ./...
        env:
          DB_HOST: localhost
          DB_PORT: 5432
          DB_USER: test_user
          DB_PASSWORD: test_password
          DB_NAME: test_db
          DB_SSLMODE: disable
          REDIS_HOST: localhost
          REDIS_PORT: 6379
          REDIS_PASSWORD: ""
          JWT_SECRET: test-jwt-secret-key-for-integration
          JWT_REFRESH_SECRET: test-jwt-refresh-secret-key

      - name: Upload Integration Test Results
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: integration-test-results
          path: |
            integration-test-results/
          retention-days: 30

  # ============================================
  # Stage 4: End-to-End Test
  # ============================================
  e2e-test:
    name: End-to-End Tests
    runs-on: ubuntu-latest
    needs: integration-test
    
    services:
      postgres:
        image: postgres:15-alpine
        env:
          POSTGRES_USER: test_user
          POSTGRES_PASSWORD: test_password
          POSTGRES_DB: test_db
        ports:
          - 5432:5432
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5

      redis:
        image: redis:7-alpine
        ports:
          - 6379:6379

    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: ${{ env.GO_VERSION }}

      - name: Download Dependencies
        run: go mod download

      - name: Build Application
        run: go build -o bin/api cmd/api/main.go

      - name: Start Application in Background
        run: |
          chmod +x bin/api
          ./bin/api &
          APP_PID=$!
          echo "APP_PID=$APP_PID" >> $GITHUB_ENV
          
          echo "Waiting for application to start..."
          for i in {1..30}; do
            if curl -f http://localhost:3000/health 2>/dev/null; then
              echo "✅ Application is running"
              break
            fi
            sleep 2
          done
        env:
          SERVER_PORT: 3000
          DB_HOST: localhost
          DB_PORT: 5432
          DB_USER: test_user
          DB_PASSWORD: test_password
          DB_NAME: test_db
          DB_SSLMODE: disable
          REDIS_HOST: localhost
          REDIS_PORT: 6379
          JWT_SECRET: test-e2e-jwt-secret
          JWT_REFRESH_SECRET: test-e2e-refresh-secret

      - name: Run E2E Tests - Health Checks
        run: |
          echo "Testing health endpoint..."
          curl -f http://localhost:3000/health || exit 1
          
          echo "Testing ready endpoint..."
          curl -f http://localhost:3000/ready || exit 1
          
          echo "✅ Health checks passed"

      - name: Run E2E Tests - Authentication Flow
        run: |
          BASE_URL="http://localhost:3000"
          
          echo "=== Test 1: User Registration ==="
          REGISTER_RESPONSE=$(curl -s -X POST $BASE_URL/api/v1/auth/register \
            -H "Content-Type: application/json" \
            -d '{
              "email": "test@example.com",
              "password": "password123",
              "first_name": "Test",
              "last_name": "User"
            }')
          
          echo "$REGISTER_RESPONSE" | jq .
          ACCESS_TOKEN=$(echo "$REGISTER_RESPONSE" | jq -r '.data.access_token')
          
          if [ "$ACCESS_TOKEN" == "null" ] || [ -z "$ACCESS_TOKEN" ]; then
            echo "❌ Registration failed"
            exit 1
          fi
          echo "✅ Registration successful"
          
          echo "=== Test 2: User Login ==="
          LOGIN_RESPONSE=$(curl -s -X POST $BASE_URL/api/v1/auth/login \
            -H "Content-Type: application/json" \
            -d '{
              "email": "test@example.com",
              "password": "password123"
            }')
          
          echo "$LOGIN_RESPONSE" | jq .
          LOGIN_TOKEN=$(echo "$LOGIN_RESPONSE" | jq -r '.data.access_token')
          
          if [ "$LOGIN_TOKEN" == "null" ] || [ -z "$LOGIN_TOKEN" ]; then
            echo "❌ Login failed"
            exit 1
          fi
          echo "✅ Login successful"
          
          echo "=== Test 3: Get User Profile ==="
          PROFILE_RESPONSE=$(curl -s -X GET $BASE_URL/api/v1/users/me \
            -H "Authorization: Bearer $LOGIN_TOKEN")
          
          echo "$PROFILE_RESPONSE" | jq .
          USER_EMAIL=$(echo "$PROFILE_RESPONSE" | jq -r '.data.email')
          
          if [ "$USER_EMAIL" != "test@example.com" ]; then
            echo "❌ Profile retrieval failed"
            exit 1
          fi
          echo "✅ Profile retrieval successful"
          
          echo "=== Test 4: List Users ==="
          USERS_RESPONSE=$(curl -s -X GET "$BASE_URL/api/v1/users?page=1&limit=10" \
            -H "Authorization: Bearer $LOGIN_TOKEN")
          
          echo "$USERS_RESPONSE" | jq .
          echo "✅ List users successful"
          
          echo "=== All E2E Tests Passed ==="

      - name: Stop Application
        if: always()
        run: |
          if [ ! -z "$APP_PID" ]; then
            kill $APP_PID || true
          fi

      - name: Upload E2E Test Logs
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: e2e-test-logs
          path: |
            logs/
          retention-days: 7

  # ============================================
  # Stage 5: Build Binary
  # ============================================
  build-binary:
    name: Build Binary
    runs-on: ubuntu-latest
    needs: e2e-test
    
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: ${{ env.GO_VERSION }}

      - name: Build Binary
        run: |
          go build -v -o bin/api cmd/api/main.go
          ls -lh bin/
          echo "✅ Binary built successfully"

      - name: Upload Binary Artifact
        uses: actions/upload-artifact@v4
        with:
          name: api-binary
          path: bin/api
          retention-days: 7

  # ============================================
  # Stage 6: Build & Push Docker Image
  # ============================================
  build-image:
    name: Build & Push Docker Image
    runs-on: ubuntu-latest
    needs: [code-analysis, unit-test, integration-test, e2e-test]
    if: github.event_name == 'push'
    
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Build and Push Docker Image
        run: |
          docker build -t ${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_REPOSITORY }}:${{ github.sha }} .
          docker tag ${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_REPOSITORY }}:${{ github.sha }} \
            ${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_REPOSITORY }}:latest
          docker push ${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_REPOSITORY }}:${{ github.sha }}
          docker push ${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_REPOSITORY }}:latest

  deploy-staging:
    name: Deploy to Staging
    runs-on: ubuntu-latest
    needs: build-image
    if: github.ref == 'refs/heads/dev'
    environment:
      name: staging
      url: https://staging.suitemedia.com
    
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Get Secrets from AWS Secrets Manager
        id: secrets
        run: |
          SECRET_JSON=$(aws secretsmanager get-secret-value \
            --secret-id staging/suitemedia/app \
            --query SecretString \
            --output text)
          
          # Export secrets as masked outputs
          echo "::add-mask::$(echo $SECRET_JSON | jq -r '.DB_PASSWORD')"
          echo "::add-mask::$(echo $SECRET_JSON | jq -r '.JWT_SECRET')"

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Update Kubeconfig
        run: |
          aws eks update-kubeconfig \
            --region ${{ env.AWS_REGION }} \
            --name ${{ env.EKS_CLUSTER_NAME }}-staging

      - name: Install Helm
        uses: azure/setup-helm@v3
        with:
          version: 'v3.13.0'

      - name: Deploy with Helm
        run: |
          helm upgrade --install suitemedia-app ./helm/suitemedia \
            --namespace staging \
            --create-namespace \
            --set image.repository=${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_REPOSITORY }} \
            --set image.tag=${{ github.sha }} \
            --set externalSecrets.enabled=true \
            --set externalSecrets.secretName=staging/suitemedia/app \
            --set externalSecrets.region=${{ env.AWS_REGION }} \
            --values ./helm/suitemedia/values-staging.yaml \
            --wait --timeout 5m

      - name: Verify Deployment
        run: |
          kubectl rollout status deployment/suitemedia-app -n staging --timeout=300s
          kubectl get pods -n staging -l app=suitemedia-app

  deploy-production:
    name: Deploy to Production
    runs-on: ubuntu-latest
    needs: build-image
    if: github.ref == 'refs/heads/main'
    environment:
      name: production
      url: https://suitemedia.com
    
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Get Secrets from AWS Secrets Manager
        id: secrets
        run: |
          SECRET_JSON=$(aws secretsmanager get-secret-value \
            --secret-id production/suitemedia/app \
            --query SecretString \
            --output text)
          
          # Mask sensitive values in logs
          echo "::add-mask::$(echo $SECRET_JSON | jq -r '.DB_PASSWORD')"
          echo "::add-mask::$(echo $SECRET_JSON | jq -r '.JWT_SECRET')"
          echo "::add-mask::$(echo $SECRET_JSON | jq -r '.JWT_REFRESH_SECRET')"
          echo "::add-mask::$(echo $SECRET_JSON | jq -r '.REDIS_PASSWORD')"

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Update Kubeconfig
        run: |
          aws eks update-kubeconfig \
            --region ${{ env.AWS_REGION }} \
            --name ${{ env.EKS_CLUSTER_NAME }}

      - name: Install Helm
        uses: azure/setup-helm@v3
        with:
          version: 'v3.13.0'

      - name: Deploy with Helm
        run: |
          helm upgrade --install suitemedia-app ./helm/suitemedia \
            --namespace production \
            --create-namespace \
            --set image.repository=${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_REPOSITORY }} \
            --set image.tag=${{ github.sha }} \
            --set externalSecrets.enabled=true \
            --set externalSecrets.secretName=production/suitemedia/app \
            --set externalSecrets.region=${{ env.AWS_REGION }} \
            --values ./helm/suitemedia/values-production.yaml \
            --wait --timeout 10m

      - name: Verify Deployment
        run: |
          kubectl rollout status deployment/suitemedia-app -n production --timeout=600s
          kubectl get pods -n production -l app=suitemedia-app

      - name: Run Smoke Tests
        run: |
          PROD_URL="https://suitemedia.com"
          for i in {1..10}; do
            if curl -f $PROD_URL/health; then
              echo "✅ Health check passed"
              break
            fi
            sleep 10
          done
